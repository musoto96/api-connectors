/**
 * BitMEX API
 * ## REST API for the BitMEX Trading Platform  _If you are building automated tools, please subscribe to the_ _[BitMEX API RSS Feed](https://blog.bitmex.com/api_announcement/feed/) for changes. The feed will be updated_ _regularly and is the most reliable way to get downtime and update announcements._  [View Changelog](/app/apiChangelog)  -  #### Getting Started  Base URI: [https://www.bitmex.com/api/v1](/api/v1)  ##### Fetching Data  All REST endpoints are documented below. You can try out any query right from this interface.  Most table queries accept `count`, `start`, and `reverse` params. Set `reverse=true` to get rows newest-first.  Additional documentation regarding filters, timestamps, and authentication is available in [the main API documentation](/app/restAPI).  _All_ table data is available via the [Websocket](/app/wsAPI). We highly recommend using the socket if you want to have the quickest possible data without being subject to ratelimits.  ##### Return Types  By default, all data is returned as JSON. Send `?_format=csv` to get CSV data or `?_format=xml` to get XML data.  ##### Trade Data Queries  _This is only a small subset of what is available, to get you started._  Fill in the parameters and click the `Try it out!` button to try any of these queries.  - [Pricing Data](#!/Quote/Quote_get)  - [Trade Data](#!/Trade/Trade_get)  - [OrderBook Data](#!/OrderBook/OrderBook_getL2)  - [Settlement Data](#!/Settlement/Settlement_get)  - [Exchange Statistics](#!/Stats/Stats_history)  Every function of the BitMEX.com platform is exposed here and documented. Many more functions are available.  ##### Swagger Specification  [â‡© Download Swagger JSON](swagger.json)  -  ## All API Endpoints  Click to expand a section. 
 *
 * OpenAPI spec version: 1.2.0
 * Contact: support@bitmex.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api

import java.text.SimpleDateFormat

import io.swagger.client.model.AccessToken
import io.swagger.client.model.Affiliate
import io.swagger.client.model.CollateralSupportAgreement
import io.swagger.client.model.CommunicationToken
import java.util.Date
import io.swagger.client.model.Error
import io.swagger.client.model.Execution
import io.swagger.client.model.Margin
import io.swagger.client.model.Number
import io.swagger.client.model.QuoteFillRatio
import io.swagger.client.model.QuoteValueRatio
import io.swagger.client.model.StakingRecord
import io.swagger.client.model.TradingVolume
import io.swagger.client.model.Transaction
import io.swagger.client.model.User
import io.swagger.client.model.UserCommissionsBySymbol
import io.swagger.client.model.Wallet
import io.swagger.client.model.XAny
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date
import java.util.TimeZone

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

import org.json4s._

class UserApi(
  val defBasePath: String = "https://www.bitmex.com/api/v1",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new UserApiAsyncHelper(client, config)

  /**
   * Cancel a withdrawal.
   * 
   *
   * @param token  
   * @return Transaction
   */
  def userCancelWithdrawal(token: String): Option[Transaction] = {
    val await = Try(Await.result(userCancelWithdrawalAsync(token), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Cancel a withdrawal. asynchronously
   * 
   *
   * @param token  
   * @return Future(Transaction)
   */
  def userCancelWithdrawalAsync(token: String): Future[Transaction] = {
      helper.userCancelWithdrawal(token)
  }

  /**
   * Check if a referral code is valid.
   * If the code is valid, responds with the referral code&#39;s discount (e.g. &#x60;0.1&#x60; for 10%). Otherwise, will return a 404 or 451 if invalid.
   *
   * @param referralCode  (optional)
   * @return Any
   */
  def userCheckReferralCode(referralCode: Option[String] = None): Option[Any] = {
    val await = Try(Await.result(userCheckReferralCodeAsync(referralCode), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Check if a referral code is valid. asynchronously
   * If the code is valid, responds with the referral code&#39;s discount (e.g. &#x60;0.1&#x60; for 10%). Otherwise, will return a 404 or 451 if invalid.
   *
   * @param referralCode  (optional)
   * @return Future(Any)
   */
  def userCheckReferralCodeAsync(referralCode: Option[String] = None): Future[Any] = {
      helper.userCheckReferralCode(referralCode)
  }

  /**
   * Register your communication token for mobile clients
   * 
   *
   * @param token  
   * @param platformAgent  
   * @return List[CommunicationToken]
   */
  def userCommunicationToken(token: String, platformAgent: String): Option[List[CommunicationToken]] = {
    val await = Try(Await.result(userCommunicationTokenAsync(token, platformAgent), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Register your communication token for mobile clients asynchronously
   * 
   *
   * @param token  
   * @param platformAgent  
   * @return Future(List[CommunicationToken])
   */
  def userCommunicationTokenAsync(token: String, platformAgent: String): Future[List[CommunicationToken]] = {
      helper.userCommunicationToken(token, platformAgent)
  }

  /**
   * Confirm your email address with a token.
   * 
   *
   * @param token  
   * @return AccessToken
   */
  def userConfirm(token: String): Option[AccessToken] = {
    val await = Try(Await.result(userConfirmAsync(token), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Confirm your email address with a token. asynchronously
   * 
   *
   * @param token  
   * @return Future(AccessToken)
   */
  def userConfirmAsync(token: String): Future[AccessToken] = {
      helper.userConfirm(token)
  }

  /**
   * Confirm a withdrawal.
   * 
   *
   * @param token  
   * @return Transaction
   */
  def userConfirmWithdrawal(token: String): Option[Transaction] = {
    val await = Try(Await.result(userConfirmWithdrawalAsync(token), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Confirm a withdrawal. asynchronously
   * 
   *
   * @param token  
   * @return Future(Transaction)
   */
  def userConfirmWithdrawalAsync(token: String): Future[Transaction] = {
      helper.userConfirmWithdrawal(token)
  }

  /**
   * Creates a new sub-account.
   * 
   *
   * @param accountName  
   * @return Any
   */
  def userCreateSubAccount(accountName: String): Option[Any] = {
    val await = Try(Await.result(userCreateSubAccountAsync(accountName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Creates a new sub-account. asynchronously
   * 
   *
   * @param accountName  
   * @return Future(Any)
   */
  def userCreateSubAccountAsync(accountName: String): Future[Any] = {
      helper.userCreateSubAccount(accountName)
  }

  /**
   * Create unstaking request
   * 
   *
   * @param symbol  
   * @param amount  
   * @return Any
   */
  def userCreateUnstakingRequests(symbol: String, amount: Double): Option[Any] = {
    val await = Try(Await.result(userCreateUnstakingRequestsAsync(symbol, amount), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create unstaking request asynchronously
   * 
   *
   * @param symbol  
   * @param amount  
   * @return Future(Any)
   */
  def userCreateUnstakingRequestsAsync(symbol: String, amount: Double): Future[Any] = {
      helper.userCreateUnstakingRequests(symbol, amount)
  }

  /**
   * Cancel unstaking request
   * 
   *
   * @param redemptionID  
   * @return Any
   */
  def userDeleteUnstakingRequests(redemptionID: String): Option[Any] = {
    val await = Try(Await.result(userDeleteUnstakingRequestsAsync(redemptionID), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Cancel unstaking request asynchronously
   * 
   *
   * @param redemptionID  
   * @return Future(Any)
   */
  def userDeleteUnstakingRequestsAsync(redemptionID: String): Future[Any] = {
      helper.userDeleteUnstakingRequests(redemptionID)
  }

  /**
   * Get your user model.
   * 
   *
   * @return User
   */
  def userGet(): Option[User] = {
    val await = Try(Await.result(userGetAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get your user model. asynchronously
   * 
   *
   * @return Future(User)
   */
  def userGetAsync(): Future[User] = {
      helper.userGet()
  }

  /**
   * Get your current affiliate/referral status.
   * 
   *
   * @param currency Any currency. For all currencies, see &lt;a href&#x3D;\&quot;#!/Wallet/Wallet_getAssetsConfig\&quot;&gt;asset config endpoint&lt;/a&gt;. For all currencies specify \&quot;all\&quot; (optional, default to XBt)
   * @return Affiliate
   */
  def userGetAffiliateStatus(currency: Option[String] = Option("XBt")): Option[Affiliate] = {
    val await = Try(Await.result(userGetAffiliateStatusAsync(currency), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get your current affiliate/referral status. asynchronously
   * 
   *
   * @param currency Any currency. For all currencies, see &lt;a href&#x3D;\&quot;#!/Wallet/Wallet_getAssetsConfig\&quot;&gt;asset config endpoint&lt;/a&gt;. For all currencies specify \&quot;all\&quot; (optional, default to XBt)
   * @return Future(Affiliate)
   */
  def userGetAffiliateStatusAsync(currency: Option[String] = Option("XBt")): Future[Affiliate] = {
      helper.userGetAffiliateStatus(currency)
  }

  /**
   * Get your account&#39;s CSA status.
   * 
   *
   * @return CollateralSupportAgreement
   */
  def userGetCSA(): Option[CollateralSupportAgreement] = {
    val await = Try(Await.result(userGetCSAAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get your account&#39;s CSA status. asynchronously
   * 
   *
   * @return Future(CollateralSupportAgreement)
   */
  def userGetCSAAsync(): Future[CollateralSupportAgreement] = {
      helper.userGetCSA()
  }

  /**
   * Get your account&#39;s commission status.
   * 
   *
   * @return UserCommissionsBySymbol
   */
  def userGetCommission(): Option[UserCommissionsBySymbol] = {
    val await = Try(Await.result(userGetCommissionAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get your account&#39;s commission status. asynchronously
   * 
   *
   * @return Future(UserCommissionsBySymbol)
   */
  def userGetCommissionAsync(): Future[UserCommissionsBySymbol] = {
      helper.userGetCommission()
  }

  /**
   * Get a deposit address.
   * 
   *
   * @param currency Any currency. For all currencies, see &lt;a href&#x3D;\&quot;#!/Wallet/Wallet_getAssetsConfig\&quot;&gt;asset config endpoint&lt;/a&gt; 
   * @param network The &#x60;network&#x60; parameter is used to indicate which blockchain you would like to deposit from. The acceptable value in the &#x60;network&#x60; parameter for each currency can be found from &#x60;networks.asset&#x60; from &#x60;GET /wallet/assets&#x60;. 
   * @return String
   */
  def userGetDepositAddress(currency: String, network: String): Option[String] = {
    val await = Try(Await.result(userGetDepositAddressAsync(currency, network), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get a deposit address. asynchronously
   * 
   *
   * @param currency Any currency. For all currencies, see &lt;a href&#x3D;\&quot;#!/Wallet/Wallet_getAssetsConfig\&quot;&gt;asset config endpoint&lt;/a&gt; 
   * @param network The &#x60;network&#x60; parameter is used to indicate which blockchain you would like to deposit from. The acceptable value in the &#x60;network&#x60; parameter for each currency can be found from &#x60;networks.asset&#x60; from &#x60;GET /wallet/assets&#x60;. 
   * @return Future(String)
   */
  def userGetDepositAddressAsync(currency: String, network: String): Future[String] = {
      helper.userGetDepositAddress(currency, network)
  }

  /**
   * Get the execution history by day.
   * 
   *
   * @param symbol  
   * @param timestamp  
   * @return List[Execution]
   */
  def userGetExecutionHistory(symbol: String = "XBTUSD", timestamp: Date = dateTimeFormatter.parse("2017-02-13T12:00:00.000Z")): Option[List[Execution]] = {
    val await = Try(Await.result(userGetExecutionHistoryAsync(symbol, timestamp), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get the execution history by day. asynchronously
   * 
   *
   * @param symbol  
   * @param timestamp  
   * @return Future(List[Execution])
   */
  def userGetExecutionHistoryAsync(symbol: String = "XBTUSD", timestamp: Date = dateTimeFormatter.parse("2017-02-13T12:00:00.000Z")): Future[List[Execution]] = {
      helper.userGetExecutionHistory(symbol, timestamp)
  }

  /**
   * Get your account&#39;s margin status. Send a currency of \&quot;all\&quot; to receive an array of all supported currencies.
   * 
   *
   * @param currency Any currency. For all currencies, see &lt;a href&#x3D;\&quot;#!/Wallet/Wallet_getAssetsConfig\&quot;&gt;asset config endpoint&lt;/a&gt;. For all currencies specify \&quot;all\&quot; (optional, default to XBt)
   * @return Margin
   */
  def userGetMargin(currency: Option[String] = Option("XBt")): Option[Margin] = {
    val await = Try(Await.result(userGetMarginAsync(currency), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get your account&#39;s margin status. Send a currency of \&quot;all\&quot; to receive an array of all supported currencies. asynchronously
   * 
   *
   * @param currency Any currency. For all currencies, see &lt;a href&#x3D;\&quot;#!/Wallet/Wallet_getAssetsConfig\&quot;&gt;asset config endpoint&lt;/a&gt;. For all currencies specify \&quot;all\&quot; (optional, default to XBt)
   * @return Future(Margin)
   */
  def userGetMarginAsync(currency: Option[String] = Option("XBt")): Future[Margin] = {
      helper.userGetMargin(currency)
  }

  /**
   * Get 7 days worth of Quote Fill Ratio statistics.
   * 
   *
   * @param targetAccountId AccountId to get quote fill ratio for, must be a paired account with main user. Can be wildcard * to get all accounts linked to the authenticated user (optional)
   * @return QuoteFillRatio
   */
  def userGetQuoteFillRatio(targetAccountId: Option[Double] = None): Option[QuoteFillRatio] = {
    val await = Try(Await.result(userGetQuoteFillRatioAsync(targetAccountId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get 7 days worth of Quote Fill Ratio statistics. asynchronously
   * 
   *
   * @param targetAccountId AccountId to get quote fill ratio for, must be a paired account with main user. Can be wildcard * to get all accounts linked to the authenticated user (optional)
   * @return Future(QuoteFillRatio)
   */
  def userGetQuoteFillRatioAsync(targetAccountId: Option[Double] = None): Future[QuoteFillRatio] = {
      helper.userGetQuoteFillRatio(targetAccountId)
  }

  /**
   * Get Quote Value Ratio statistics over the last 3 days
   * 
   *
   * @param targetAccountId AccountId to get quote value ratio for, must be a paired account with main user. Can be wildcard * to get all accounts linked to the authenticated user (optional)
   * @return QuoteValueRatio
   */
  def userGetQuoteValueRatio(targetAccountId: Option[Double] = None): Option[QuoteValueRatio] = {
    val await = Try(Await.result(userGetQuoteValueRatioAsync(targetAccountId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Quote Value Ratio statistics over the last 3 days asynchronously
   * 
   *
   * @param targetAccountId AccountId to get quote value ratio for, must be a paired account with main user. Can be wildcard * to get all accounts linked to the authenticated user (optional)
   * @return Future(QuoteValueRatio)
   */
  def userGetQuoteValueRatioAsync(targetAccountId: Option[Double] = None): Future[QuoteValueRatio] = {
      helper.userGetQuoteValueRatio(targetAccountId)
  }

  /**
   * Get the current user staking amount.
   * 
   *
   * @param currency  (optional)
   * @return List[StakingRecord]
   */
  def userGetStaking(currency: Option[String] = None): Option[List[StakingRecord]] = {
    val await = Try(Await.result(userGetStakingAsync(currency), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get the current user staking amount. asynchronously
   * 
   *
   * @param currency  (optional)
   * @return Future(List[StakingRecord])
   */
  def userGetStakingAsync(currency: Option[String] = None): Future[List[StakingRecord]] = {
      helper.userGetStaking(currency)
  }

  /**
   * List staking instruments
   * 
   *
   * @param symbol  (optional)
   * @param currency  (optional)
   * @return List[XAny]
   */
  def userGetStakingInstruments(symbol: Option[String] = None, currency: Option[String] = None): Option[List[XAny]] = {
    val await = Try(Await.result(userGetStakingInstrumentsAsync(symbol, currency), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List staking instruments asynchronously
   * 
   *
   * @param symbol  (optional)
   * @param currency  (optional)
   * @return Future(List[XAny])
   */
  def userGetStakingInstrumentsAsync(symbol: Option[String] = None, currency: Option[String] = None): Future[List[XAny]] = {
      helper.userGetStakingInstruments(symbol, currency)
  }

  /**
   * List staking tiers for a given currency
   * 
   *
   * @param currency  
   * @return List[XAny]
   */
  def userGetStakingTiers(currency: String): Option[List[XAny]] = {
    val await = Try(Await.result(userGetStakingTiersAsync(currency), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List staking tiers for a given currency asynchronously
   * 
   *
   * @param currency  
   * @return Future(List[XAny])
   */
  def userGetStakingTiersAsync(currency: String): Future[List[XAny]] = {
      helper.userGetStakingTiers(currency)
  }

  /**
   * Get your 30 days USD average trading volume
   * 
   *
   * @return List[TradingVolume]
   */
  def userGetTradingVolume(): Option[List[TradingVolume]] = {
    val await = Try(Await.result(userGetTradingVolumeAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get your 30 days USD average trading volume asynchronously
   * 
   *
   * @return Future(List[TradingVolume])
   */
  def userGetTradingVolumeAsync(): Future[List[TradingVolume]] = {
      helper.userGetTradingVolume()
  }

  /**
   * Get the current user unstaking requests
   * 
   *
   * @param status  
   * @return List[StakingRecord]
   */
  def userGetUnstakingRequests(status: String): Option[List[StakingRecord]] = {
    val await = Try(Await.result(userGetUnstakingRequestsAsync(status), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get the current user unstaking requests asynchronously
   * 
   *
   * @param status  
   * @return Future(List[StakingRecord])
   */
  def userGetUnstakingRequestsAsync(status: String): Future[List[StakingRecord]] = {
      helper.userGetUnstakingRequests(status)
  }

  /**
   * Get your current wallet information.
   * 
   *
   * @param currency Any currency. For all currencies, see &lt;a href&#x3D;\&quot;#!/Wallet/Wallet_getAssetsConfig\&quot;&gt;asset config endpoint&lt;/a&gt;. For all currencies specify \&quot;all\&quot; (optional, default to XBt)
   * @return Wallet
   */
  def userGetWallet(currency: Option[String] = Option("XBt")): Option[Wallet] = {
    val await = Try(Await.result(userGetWalletAsync(currency), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get your current wallet information. asynchronously
   * 
   *
   * @param currency Any currency. For all currencies, see &lt;a href&#x3D;\&quot;#!/Wallet/Wallet_getAssetsConfig\&quot;&gt;asset config endpoint&lt;/a&gt;. For all currencies specify \&quot;all\&quot; (optional, default to XBt)
   * @return Future(Wallet)
   */
  def userGetWalletAsync(currency: Option[String] = Option("XBt")): Future[Wallet] = {
      helper.userGetWallet(currency)
  }

  /**
   * Get a history of all of your wallet transactions (deposits, withdrawals, PNL).
   * 
   *
   * @param currency Any currency. For all currencies, see &lt;a href&#x3D;\&quot;#!/Wallet/Wallet_getAssetsConfig\&quot;&gt;asset config endpoint&lt;/a&gt;. For all currencies specify \&quot;all\&quot; (optional, default to XBt)
   * @param count Number of results to fetch. (optional, default to 100)
   * @param start Starting point for results. (optional, default to 0)
   * @param targetAccountId AccountId to view the history of, must be a paired account with the authorised user requesting the history. (optional)
   * @return List[Transaction]
   */
  def userGetWalletHistory(currency: Option[String] = Option("XBt"), count: Option[Double] = Option(100), start: Option[Double] = Option(0), targetAccountId: Option[Double] = None): Option[List[Transaction]] = {
    val await = Try(Await.result(userGetWalletHistoryAsync(currency, count, start, targetAccountId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get a history of all of your wallet transactions (deposits, withdrawals, PNL). asynchronously
   * 
   *
   * @param currency Any currency. For all currencies, see &lt;a href&#x3D;\&quot;#!/Wallet/Wallet_getAssetsConfig\&quot;&gt;asset config endpoint&lt;/a&gt;. For all currencies specify \&quot;all\&quot; (optional, default to XBt)
   * @param count Number of results to fetch. (optional, default to 100)
   * @param start Starting point for results. (optional, default to 0)
   * @param targetAccountId AccountId to view the history of, must be a paired account with the authorised user requesting the history. (optional)
   * @return Future(List[Transaction])
   */
  def userGetWalletHistoryAsync(currency: Option[String] = Option("XBt"), count: Option[Double] = Option(100), start: Option[Double] = Option(0), targetAccountId: Option[Double] = None): Future[List[Transaction]] = {
      helper.userGetWalletHistory(currency, count, start, targetAccountId)
  }

  /**
   * Get a summary of all of your wallet transactions (deposits, withdrawals, PNL).
   * 
   *
   * @param currency Any currency. For all currencies, see &lt;a href&#x3D;\&quot;#!/Wallet/Wallet_getAssetsConfig\&quot;&gt;asset config endpoint&lt;/a&gt;. For all currencies specify \&quot;all\&quot; (optional, default to XBt)
   * @return List[Transaction]
   */
  def userGetWalletSummary(currency: Option[String] = Option("XBt")): Option[List[Transaction]] = {
    val await = Try(Await.result(userGetWalletSummaryAsync(currency), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get a summary of all of your wallet transactions (deposits, withdrawals, PNL). asynchronously
   * 
   *
   * @param currency Any currency. For all currencies, see &lt;a href&#x3D;\&quot;#!/Wallet/Wallet_getAssetsConfig\&quot;&gt;asset config endpoint&lt;/a&gt;. For all currencies specify \&quot;all\&quot; (optional, default to XBt)
   * @return Future(List[Transaction])
   */
  def userGetWalletSummaryAsync(currency: Option[String] = Option("XBt")): Future[List[Transaction]] = {
      helper.userGetWalletSummary(currency)
  }

  /**
   * Get the list of accounts you can transfer funds between.
   * 
   *
   * @return List[XAny]
   */
  def userGetWalletTransferAccounts(): Option[List[XAny]] = {
    val await = Try(Await.result(userGetWalletTransferAccountsAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get the list of accounts you can transfer funds between. asynchronously
   * 
   *
   * @return Future(List[XAny])
   */
  def userGetWalletTransferAccountsAsync(): Future[List[XAny]] = {
      helper.userGetWalletTransferAccounts()
  }

  /**
   * Log out of BitMEX.
   * 
   *
   * @return void
   */
  def userLogout() = {
    val await = Try(Await.result(userLogoutAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Log out of BitMEX. asynchronously
   * 
   *
   * @return Future(void)
   */
  def userLogoutAsync() = {
      helper.userLogout()
  }

  /**
   * Request a withdrawal to an external wallet.
   * This will send a confirmation email to the email address on record.
   *
   * @param currency Currency you&#39;re withdrawing. Any currency. For all currencies, see &lt;a href&#x3D;\&quot;#!/Wallet/Wallet_getAssetsConfig\&quot;&gt;asset config endpoint&lt;/a&gt; 
   * @param network The &#x60;network&#x60; parameter is used to indicate which blockchain you would like to withdraw from. The acceptable value in the &#x60;network&#x60; parameter for each currency can be found from &#x60;networks.asset&#x60; from &#x60;GET /wallet/assets&#x60;. 
   * @param amount Amount of withdrawal currency. 
   * @param otpToken 2FA token. Required for all external withdrawals unless the address has skip2FA in addressbook. (optional)
   * @param address Destination Address. One of &#x60;address&#x60;, &#x60;addressId&#x60;, &#x60;targetUserId&#x60; has to be specified. (optional)
   * @param addressId ID of the Destination Address. One of &#x60;address&#x60;, &#x60;addressId&#x60;, &#x60;targetUserId&#x60; has to be specified. (optional)
   * @param targetUserId ID of the Target User. One of &#x60;address&#x60;, &#x60;addressId&#x60;, &#x60;targetUserId&#x60; has to be specified. (optional)
   * @param fee Network fee for Bitcoin withdrawals. If not specified, a default value will be calculated based on Bitcoin network conditions. You will have a chance to confirm this via email. (optional)
   * @param text Optional annotation, e.g. &#39;Transfer to home wallet&#39;. (optional)
   * @return Transaction
   */
  def userRequestWithdrawal(currency: String = "XBt", network: String, amount: Number, otpToken: Option[String] = None, address: Option[String] = None, addressId: Option[Double] = None, targetUserId: Option[Double] = None, fee: Option[Double] = None, text: Option[String] = None): Option[Transaction] = {
    val await = Try(Await.result(userRequestWithdrawalAsync(currency, network, amount, otpToken, address, addressId, targetUserId, fee, text), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Request a withdrawal to an external wallet. asynchronously
   * This will send a confirmation email to the email address on record.
   *
   * @param currency Currency you&#39;re withdrawing. Any currency. For all currencies, see &lt;a href&#x3D;\&quot;#!/Wallet/Wallet_getAssetsConfig\&quot;&gt;asset config endpoint&lt;/a&gt; 
   * @param network The &#x60;network&#x60; parameter is used to indicate which blockchain you would like to withdraw from. The acceptable value in the &#x60;network&#x60; parameter for each currency can be found from &#x60;networks.asset&#x60; from &#x60;GET /wallet/assets&#x60;. 
   * @param amount Amount of withdrawal currency. 
   * @param otpToken 2FA token. Required for all external withdrawals unless the address has skip2FA in addressbook. (optional)
   * @param address Destination Address. One of &#x60;address&#x60;, &#x60;addressId&#x60;, &#x60;targetUserId&#x60; has to be specified. (optional)
   * @param addressId ID of the Destination Address. One of &#x60;address&#x60;, &#x60;addressId&#x60;, &#x60;targetUserId&#x60; has to be specified. (optional)
   * @param targetUserId ID of the Target User. One of &#x60;address&#x60;, &#x60;addressId&#x60;, &#x60;targetUserId&#x60; has to be specified. (optional)
   * @param fee Network fee for Bitcoin withdrawals. If not specified, a default value will be calculated based on Bitcoin network conditions. You will have a chance to confirm this via email. (optional)
   * @param text Optional annotation, e.g. &#39;Transfer to home wallet&#39;. (optional)
   * @return Future(Transaction)
   */
  def userRequestWithdrawalAsync(currency: String = "XBt", network: String, amount: Number, otpToken: Option[String] = None, address: Option[String] = None, addressId: Option[Double] = None, targetUserId: Option[Double] = None, fee: Option[Double] = None, text: Option[String] = None): Future[Transaction] = {
      helper.userRequestWithdrawal(currency, network, amount, otpToken, address, addressId, targetUserId, fee, text)
  }

  /**
   * Save user preferences.
   * 
   *
   * @param prefs  
   * @param overwrite If true, will overwrite all existing preferences. (optional, default to false)
   * @return User
   */
  def userSavePreferences(prefs: String, overwrite: Option[Boolean] = Option(false)): Option[User] = {
    val await = Try(Await.result(userSavePreferencesAsync(prefs, overwrite), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Save user preferences. asynchronously
   * 
   *
   * @param prefs  
   * @param overwrite If true, will overwrite all existing preferences. (optional, default to false)
   * @return Future(User)
   */
  def userSavePreferencesAsync(prefs: String, overwrite: Option[Boolean] = Option(false)): Future[User] = {
      helper.userSavePreferences(prefs, overwrite)
  }

  /**
   * Updates the sub-account name.
   * 
   *
   * @param targetAccountId  
   * @param accountName  
   * @return Any
   */
  def userUpdateSubAccount(targetAccountId: Double, accountName: String): Option[Any] = {
    val await = Try(Await.result(userUpdateSubAccountAsync(targetAccountId, accountName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Updates the sub-account name. asynchronously
   * 
   *
   * @param targetAccountId  
   * @param accountName  
   * @return Future(Any)
   */
  def userUpdateSubAccountAsync(targetAccountId: Double, accountName: String): Future[Any] = {
      helper.userUpdateSubAccount(targetAccountId, accountName)
  }

  /**
   * Execute a transfer to a paired account.
   * This will send a confirmation email to the email address on record.
   *
   * @param currency Currency you&#39;re transfering. Any currency. For all currencies, see &lt;a href&#x3D;\&quot;#!/Wallet/Wallet_getAssetsConfig\&quot;&gt;asset config endpoint&lt;/a&gt; 
   * @param amount Amount of transfer. 
   * @param targetAccountId AccountId to send the transfer to, must be a paired account with the user sending the transfer. 
   * @param fromAccountId AccountID to send the transfer from. Must be paired account with the authenticated user. (optional)
   * @return Transaction
   */
  def userWalletTransfer(currency: String, amount: Number, targetAccountId: Double, fromAccountId: Option[Double] = None): Option[Transaction] = {
    val await = Try(Await.result(userWalletTransferAsync(currency, amount, targetAccountId, fromAccountId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Execute a transfer to a paired account. asynchronously
   * This will send a confirmation email to the email address on record.
   *
   * @param currency Currency you&#39;re transfering. Any currency. For all currencies, see &lt;a href&#x3D;\&quot;#!/Wallet/Wallet_getAssetsConfig\&quot;&gt;asset config endpoint&lt;/a&gt; 
   * @param amount Amount of transfer. 
   * @param targetAccountId AccountId to send the transfer to, must be a paired account with the user sending the transfer. 
   * @param fromAccountId AccountID to send the transfer from. Must be paired account with the authenticated user. (optional)
   * @return Future(Transaction)
   */
  def userWalletTransferAsync(currency: String, amount: Number, targetAccountId: Double, fromAccountId: Option[Double] = None): Future[Transaction] = {
      helper.userWalletTransfer(currency, amount, targetAccountId, fromAccountId)
  }

}

class UserApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def userCancelWithdrawal(token: String)(implicit reader: ClientResponseReader[Transaction]): Future[Transaction] = {
    // create path and map variables
    val path = (addFmt("/user/cancelWithdrawal"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (token == null) throw new Exception("Missing required parameter 'token' when calling UserApi->userCancelWithdrawal")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userCheckReferralCode(referralCode: Option[String] = None
    )(implicit reader: ClientResponseReader[Any]): Future[Any] = {
    // create path and map variables
    val path = (addFmt("/user/checkReferralCode"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    referralCode match {
      case Some(param) => queryParams += "referralCode" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userCommunicationToken(token: String,
    platformAgent: String)(implicit reader: ClientResponseReader[List[CommunicationToken]]): Future[List[CommunicationToken]] = {
    // create path and map variables
    val path = (addFmt("/user/communicationToken"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (token == null) throw new Exception("Missing required parameter 'token' when calling UserApi->userCommunicationToken")

    if (platformAgent == null) throw new Exception("Missing required parameter 'platformAgent' when calling UserApi->userCommunicationToken")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userConfirm(token: String)(implicit reader: ClientResponseReader[AccessToken]): Future[AccessToken] = {
    // create path and map variables
    val path = (addFmt("/user/confirmEmail"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (token == null) throw new Exception("Missing required parameter 'token' when calling UserApi->userConfirm")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userConfirmWithdrawal(token: String)(implicit reader: ClientResponseReader[Transaction]): Future[Transaction] = {
    // create path and map variables
    val path = (addFmt("/user/confirmWithdrawal"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (token == null) throw new Exception("Missing required parameter 'token' when calling UserApi->userConfirmWithdrawal")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userCreateSubAccount(accountName: String)(implicit reader: ClientResponseReader[Any]): Future[Any] = {
    // create path and map variables
    val path = (addFmt("/user/addSubaccount"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (accountName == null) throw new Exception("Missing required parameter 'accountName' when calling UserApi->userCreateSubAccount")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userCreateUnstakingRequests(symbol: String,
    amount: Double)(implicit reader: ClientResponseReader[Any]): Future[Any] = {
    // create path and map variables
    val path = (addFmt("/user/unstakingRequests"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (symbol == null) throw new Exception("Missing required parameter 'symbol' when calling UserApi->userCreateUnstakingRequests")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userDeleteUnstakingRequests(redemptionID: String)(implicit reader: ClientResponseReader[Any]): Future[Any] = {
    // create path and map variables
    val path = (addFmt("/user/unstakingRequests"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (redemptionID == null) throw new Exception("Missing required parameter 'redemptionID' when calling UserApi->userDeleteUnstakingRequests")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userGet()(implicit reader: ClientResponseReader[User]): Future[User] = {
    // create path and map variables
    val path = (addFmt("/user"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userGetAffiliateStatus(currency: Option[String] = Option("XBt")
    )(implicit reader: ClientResponseReader[Affiliate]): Future[Affiliate] = {
    // create path and map variables
    val path = (addFmt("/user/affiliateStatus"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    currency match {
      case Some(param) => queryParams += "currency" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userGetCSA()(implicit reader: ClientResponseReader[CollateralSupportAgreement]): Future[CollateralSupportAgreement] = {
    // create path and map variables
    val path = (addFmt("/user/csa"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userGetCommission()(implicit reader: ClientResponseReader[UserCommissionsBySymbol]): Future[UserCommissionsBySymbol] = {
    // create path and map variables
    val path = (addFmt("/user/commission"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userGetDepositAddress(currency: String,
    network: String)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/user/depositAddress"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (currency == null) throw new Exception("Missing required parameter 'currency' when calling UserApi->userGetDepositAddress")

    if (network == null) throw new Exception("Missing required parameter 'network' when calling UserApi->userGetDepositAddress")

    queryParams += "currency" -> currency.toString
    queryParams += "network" -> network.toString

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userGetExecutionHistory(symbol: String = "XBTUSD",
    timestamp: Date = dateTimeFormatter.parse("2017-02-13T12:00:00.000Z"))(implicit reader: ClientResponseReader[List[Execution]]): Future[List[Execution]] = {
    // create path and map variables
    val path = (addFmt("/user/executionHistory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (symbol == null) throw new Exception("Missing required parameter 'symbol' when calling UserApi->userGetExecutionHistory")

    queryParams += "symbol" -> symbol.toString
    queryParams += "timestamp" -> timestamp.toString

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userGetMargin(currency: Option[String] = Option("XBt")
    )(implicit reader: ClientResponseReader[Margin]): Future[Margin] = {
    // create path and map variables
    val path = (addFmt("/user/margin"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    currency match {
      case Some(param) => queryParams += "currency" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userGetQuoteFillRatio(targetAccountId: Option[Double] = None
    )(implicit reader: ClientResponseReader[QuoteFillRatio]): Future[QuoteFillRatio] = {
    // create path and map variables
    val path = (addFmt("/user/quoteFillRatio"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    targetAccountId match {
      case Some(param) => queryParams += "targetAccountId" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userGetQuoteValueRatio(targetAccountId: Option[Double] = None
    )(implicit reader: ClientResponseReader[QuoteValueRatio]): Future[QuoteValueRatio] = {
    // create path and map variables
    val path = (addFmt("/user/quoteValueRatio"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    targetAccountId match {
      case Some(param) => queryParams += "targetAccountId" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userGetStaking(currency: Option[String] = None
    )(implicit reader: ClientResponseReader[List[StakingRecord]]): Future[List[StakingRecord]] = {
    // create path and map variables
    val path = (addFmt("/user/staking"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    currency match {
      case Some(param) => queryParams += "currency" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userGetStakingInstruments(symbol: Option[String] = None,
    currency: Option[String] = None
    )(implicit reader: ClientResponseReader[List[XAny]]): Future[List[XAny]] = {
    // create path and map variables
    val path = (addFmt("/user/staking/instruments"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    symbol match {
      case Some(param) => queryParams += "symbol" -> param.toString
      case _ => queryParams
    }
    currency match {
      case Some(param) => queryParams += "currency" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userGetStakingTiers(currency: String)(implicit reader: ClientResponseReader[List[XAny]]): Future[List[XAny]] = {
    // create path and map variables
    val path = (addFmt("/user/staking/tiers"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (currency == null) throw new Exception("Missing required parameter 'currency' when calling UserApi->userGetStakingTiers")

    queryParams += "currency" -> currency.toString

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userGetTradingVolume()(implicit reader: ClientResponseReader[List[TradingVolume]]): Future[List[TradingVolume]] = {
    // create path and map variables
    val path = (addFmt("/user/tradingVolume"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userGetUnstakingRequests(status: String)(implicit reader: ClientResponseReader[List[StakingRecord]]): Future[List[StakingRecord]] = {
    // create path and map variables
    val path = (addFmt("/user/unstakingRequests"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (status == null) throw new Exception("Missing required parameter 'status' when calling UserApi->userGetUnstakingRequests")

    queryParams += "status" -> status.toString

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userGetWallet(currency: Option[String] = Option("XBt")
    )(implicit reader: ClientResponseReader[Wallet]): Future[Wallet] = {
    // create path and map variables
    val path = (addFmt("/user/wallet"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    currency match {
      case Some(param) => queryParams += "currency" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userGetWalletHistory(currency: Option[String] = Option("XBt"),
    count: Option[Double] = Option(100),
    start: Option[Double] = Option(0),
    targetAccountId: Option[Double] = None
    )(implicit reader: ClientResponseReader[List[Transaction]]): Future[List[Transaction]] = {
    // create path and map variables
    val path = (addFmt("/user/walletHistory"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    currency match {
      case Some(param) => queryParams += "currency" -> param.toString
      case _ => queryParams
    }
    count match {
      case Some(param) => queryParams += "count" -> param.toString
      case _ => queryParams
    }
    start match {
      case Some(param) => queryParams += "start" -> param.toString
      case _ => queryParams
    }
    targetAccountId match {
      case Some(param) => queryParams += "targetAccountId" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userGetWalletSummary(currency: Option[String] = Option("XBt")
    )(implicit reader: ClientResponseReader[List[Transaction]]): Future[List[Transaction]] = {
    // create path and map variables
    val path = (addFmt("/user/walletSummary"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    currency match {
      case Some(param) => queryParams += "currency" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userGetWalletTransferAccounts()(implicit reader: ClientResponseReader[List[XAny]]): Future[List[XAny]] = {
    // create path and map variables
    val path = (addFmt("/user/getWalletTransferAccounts"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userLogout()(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/user/logout"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userRequestWithdrawal(currency: String = "XBt",
    network: String,
    amount: Number,
    otpToken: Option[String] = None,
    address: Option[String] = None,
    addressId: Option[Double] = None,
    targetUserId: Option[Double] = None,
    fee: Option[Double] = None,
    text: Option[String] = None
    )(implicit reader: ClientResponseReader[Transaction]): Future[Transaction] = {
    // create path and map variables
    val path = (addFmt("/user/requestWithdrawal"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (currency == null) throw new Exception("Missing required parameter 'currency' when calling UserApi->userRequestWithdrawal")

    if (network == null) throw new Exception("Missing required parameter 'network' when calling UserApi->userRequestWithdrawal")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userSavePreferences(prefs: String,
    overwrite: Option[Boolean] = Option(false)
    )(implicit reader: ClientResponseReader[User]): Future[User] = {
    // create path and map variables
    val path = (addFmt("/user/preferences"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (prefs == null) throw new Exception("Missing required parameter 'prefs' when calling UserApi->userSavePreferences")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userUpdateSubAccount(targetAccountId: Double,
    accountName: String)(implicit reader: ClientResponseReader[Any]): Future[Any] = {
    // create path and map variables
    val path = (addFmt("/user/updateSubaccount"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (accountName == null) throw new Exception("Missing required parameter 'accountName' when calling UserApi->userUpdateSubAccount")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userWalletTransfer(currency: String,
    amount: Number,
    targetAccountId: Double,
    fromAccountId: Option[Double] = None
    )(implicit reader: ClientResponseReader[Transaction]): Future[Transaction] = {
    // create path and map variables
    val path = (addFmt("/user/walletTransfer"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (currency == null) throw new Exception("Missing required parameter 'currency' when calling UserApi->userWalletTransfer")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
